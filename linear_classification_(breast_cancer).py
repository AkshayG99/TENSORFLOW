# -*- coding: utf-8 -*-
"""Linear Classification (Breast Cancer)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ww5a6xcJuKgIb3x4H4b1nk1VtiM9nMWY
"""

#import tensorflow
import tensorflow as tf

#load in the data
from sklearn.datasets import load_breast_cancer

#load breast cancer database and make it equal to data
data = load_breast_cancer()

#print out data
data

#show object type
type(data)

#show keys in bunch object
data.keys()

#numpy array - call shape to see number of samples (n) and features (d)
data.data.shape

# f(x) value or in this case tumor type called target
#binary classification problem - only 1's and 0's
data.target

#find meaning of targets
#malignant = 0 and benign = 1
data.target_names

#find number of targets
data.target.shape

data.data

#meaning of each column
#does not matter what each column actually means unless need to explain
data.feature_names

#train our model
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.33)

#Shape X_train
N, D = X_train.shape

#find what N and D are
N, D

#go through every column and data set and make it have 0 mean and varients 1
#standard deviation
from sklearn.preprocessing import StandardScaler

#Object oriented programming
scaler = StandardScaler()
#fit on trainset to find parameters (standard deviation of each column)
#when see new datapoint would use that to transform data
X_train = scaler.fit_transform(X_train)

X_test = scaler.transform(X_test)

#tensor flow stuff
#create model
model = tf.keras.models.Sequential([
    tf.keras.layers.Input(shape=(D,)),
    tf.keras.layers.Dense(1, activation="sigmoid")
])

#Alternative
#model = model = tf.keras.models.Sequential()
#can use model.add()

#import binary_crossentropy
from keras.losses import binary_crossentropy

#compile the
#binary_crossentrophy goes with sigmoid which goes with binary classification
model.compile(optimizer="adam",
              loss="binary_crossentropy",
              metrics=["accuracy"])

#train model
r = model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=100)

#evaluate model
#loss than accuracy
#pretty well for this dataset
print("Train score:", model.evaluate(X_train, y_train ))
print("Test score: ", model.evaluate(X_test, y_test))

#plot loss per epoch and accuracy per epoch
#history contains loss per epoch
import matplotlib.pyplot as plt
plt.plot(r.history["loss"], label="loss")
plt.plot(r.history["val_loss"], label="val_loss")
#to see the labels
plt.legend();

#plot accuracy
plt.plot(r.history["accuracy"], label="acc")
plt.plot(r.history["val_accuracy"], label="val_acc")
plt.legend;

#MAKING PREDICTIONS
#pass in 2d array of x containing a bunch of samples
P = model.predict(X_test)
print(P) #outputs of the sigmoid, interpreted as probabilities p(y = 1 | x)

# round predictions
# flatten array because targets are size (N,) while the predictions are size (N, 1)
import numpy as np
P = np.round(P).flatten()
print(P)

# Calculate the accuracy, compare it to evaluate()
# "==" on 2 numpy arrays does a element wise comparision, gives array of length n of booleans (true if target = prediction, false if target != prediction)
print("Manually Calculated Accuracy:", np.mean(P == y_test))
print("Evaluate output:", model.evaluate(X_test, y_test))

#SAVE AND LOAD MODEL

#save model to file
model.save("linearclassifier.h5")

#Check that model file exists
!ls -lh

#Load in model and confirm it works
model = tf.keras.models.load_model("linearclassifier.h5")
print(model.layers)
model.evaluate(X_test, y_test)

#from google.colab import files
#files.download("linearclassifier.h5")